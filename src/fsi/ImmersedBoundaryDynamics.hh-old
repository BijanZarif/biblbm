#ifndef IMMERSEDBOUNDARYDYNAMICS_HH_
#define IMMERSEDBOUNDARYDYNAMICS_HH_
#include "ImmersedBoundaryDynamics.h"
#include "atomicBlock/dataProcessor3D.h"
#include "core/geometry3D.h"
#include <algorithm>
#include "CommunicationBuffer.hh"
#include "ParticleShapeFactory.h"
#include <sstream>
#include "MacroProcessors.h"
#include "Boundary.h"
#include <stdexcept>
#include "IO.h"
#include "Buffer.h"

#define FSI_PROFILE
#include "Profile.h"


namespace plb {

namespace fsi {

/*------ SolidNodeList ------*/
template<class T>
void SolidNodeList<T>::push_node(const SolidNode<T> & node)
{
	if(solid_node_capacity <= solid_node_count) {
		solid_node_capacity *= 2;
		SolidNode<T> * tmp = new SolidNode<T>[solid_node_capacity];
		std::copy(solid_nodes, solid_nodes+solid_node_count, tmp);
		delete [] solid_nodes;
		solid_nodes = tmp;
	}
	solid_nodes[solid_node_count++] = node;
}


/*------ ImmersedBoundaryDynamics3D ------*/
template<class T, template<typename U> class Descriptor, class Periodicity>
ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::ImmersedBoundaryDynamics3D(
		const MultiBlockLattice3D<T, Descriptor> & lattice,
		const ParticleShapeLibrary<T> & shape_library_)
: shape_library(shape_library_),
  management(lattice.getMultiBlockManagement()),
  num_particles(0),
  particle_max_radius(0),
  arithmetic(Periodicity::create_arithmetic(lattice.getBoundingBox())),
  particle_force_communicator(particles, Periodicity::create_arithmetic(lattice.getBoundingBox())),
  particle_state_communicator(Periodicity::create_arithmetic(lattice.getBoundingBox())),
  fsi_force_communicator(Periodicity::create_arithmetic(lattice.getBoundingBox())),
  output_stream(0),
  fsi_subiterations(1),
  boundary(0),
  global_bounding_box(lattice.getBoundingBox()),
  nx(lattice.getNx()),
  ny(lattice.getNy()),
  nz(lattice.getNz()),
  quad(4)
{
	initialize_domains();
	initialize_periodicity(lattice);
	initialize_fsi_communicator();
	set_interaction_cutoff_distance(1.0);
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::initialize_domains()
{
	// Get the block ids corresponding to the current MPI process
	std::vector<plint> local_blocks = management.getSparseBlockStructure().getLocalBlocks(management.getThreadAttribution());

	if(local_blocks.size() != 1) {
		pcerr << "The fsi module can only handle multiblock representations with 1 block per thread" << std::endl;
		exit(-1);
	}

	// Save local domain
	management.getSparseBlockStructure().getBulk(local_blocks[0], domain);

	// Save domain with envelope
	domain_with_fsi_envelope = domain;
	domain_with_fsi_envelope.enlarge_inplace(Dirac::half_support);

	// Bulk domain (nodes in this subdomain does not depend on entities in other processors)
	// By doing this subdivision, a lot of if-else statements can be avoided in the
	// cpu-intensive loops and branching can thus be kept at a minimum.
	bulk_domain = domain;
	bulk_domain.enlarge_inplace(-Dirac::half_support + 1.0);

	// Set domain for collision checking
	grid.set_domain(geo::Rect<T>(
			domain.x0-0.5, domain.x1+0.5-std::numeric_limits<T>::epsilon(),
			domain.y0-0.5, domain.y1+0.5-std::numeric_limits<T>::epsilon(),
			domain.z0-0.5, domain.z1+0.5-std::numeric_limits<T>::epsilon()));
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::initialize_periodicity(const MultiBlockLattice3D<T, Descriptor> & lattice)
{
	// Verify that the lattice has the same periodicity as that defined by the Periodicity template parameter
	if(lattice.periodicity().get(0) != Periodicity::get_x() ||
		lattice.periodicity().get(1) != Periodicity::get_y() ||
		lattice.periodicity().get(2) != Periodicity::get_z())
	{
		std::cerr << "The lattice must have the same periodicity as the fsi module." << std::endl
				<< "Check the 3rd template parameter of the ImmersedBoundaryDynamics3D class" << std::endl;
		exit(-1);
	}

	// Check if the local domain has edges that are connected by periodic boundary conditions
	has_periodic_edge[0] = has_periodic_edge[1] = has_periodic_edge[2] = false;
	if(Periodicity::get_x() && domain.x0 == global_bounding_box.x0 && domain.x1 == global_bounding_box.x1)
		has_periodic_edge[0] = true;
	if(Periodicity::get_y() && domain.y0 == global_bounding_box.y0 && domain.y1 == global_bounding_box.y1)
		has_periodic_edge[1] = true;
	if(Periodicity::get_z() && domain.z0 == global_bounding_box.z0 && domain.z1 == global_bounding_box.z1)
		has_periodic_edge[2] = true;
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::initialize_fsi_communicator()
{
	const SparseBlockStructure3D & block_structure = management.getSparseBlockStructure();
	const ThreadAttribution & thread_info = management.getThreadAttribution();

	// Neighboring processors
	std::vector<plint> neighboring_processors;

	// Atomic blocks of the neighboring processors
	std::vector<std::pair<geo::Rect<T>, plint> > domain_proc_map;

	// Find neighboring blocks
	std::vector<plint> neighboring_blocks;
	find_blocks_in_domain(domain_with_fsi_envelope, neighboring_blocks);

	// Get the processor ids corresponding to the neighboring blocks
	for(std::vector<plint>::iterator it = neighboring_blocks.begin(); it != neighboring_blocks.end(); ++it) {
		if(thread_info.isLocal(*it))
			continue;

		Box3D box;
		block_structure.getBulk(*it, box);
		plint proc_id = thread_info.getMpiProcess(*it);
		geo::Rect<T> box_with_envelope(box);
		box_with_envelope.enlarge_inplace(Dirac::half_support);

		domain_proc_map.push_back(std::make_pair(box_with_envelope, proc_id));

		// Avoid adding duplicates
		if(std::find(neighboring_processors.begin(), neighboring_processors.end(), proc_id) == neighboring_processors.end())
			neighboring_processors.push_back(proc_id);
	}

	fsi_force_communicator.set_proc_list(neighboring_processors);
	fsi_force_communicator.set_domain_proc_map(domain_proc_map);
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::find_blocks_in_domain(
		const geo::Rect<T> & bb,
		std::vector<plint> & neighboring_blocks
) const
{
	neighboring_blocks.clear();
	const std::map<plint,Box3D> & blocks = management.getSparseBlockStructure().getBulks();
	for(std::map<plint,Box3D>::const_iterator it = blocks.begin(); it != blocks.end(); ++it) {
		geo::Rect<T> domain_to_test(it->second);
		if(geo::does_intersect(bb, domain_to_test, arithmetic))
			neighboring_blocks.push_back(it->first);
	}
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::set_interaction_cutoff_distance(T val)
{
	// Save interaction distance and its square
	interaction_distance = val;
	interaction_distance_sqr = val*val;

	// Update the interaction domain
	interaction_domain = domain;
	interaction_domain.enlarge_inplace(interaction_distance);

	// Set the bounding domain
	domain_bounds = geo::Rect<T>(
		std::min(interaction_domain.x0, domain_with_fsi_envelope.x0),
		std::max(interaction_domain.x1, domain_with_fsi_envelope.x1),
		std::min(interaction_domain.y0, domain_with_fsi_envelope.y0),
		std::max(interaction_domain.y1, domain_with_fsi_envelope.y1),
		std::min(interaction_domain.z0, domain_with_fsi_envelope.z0),
		std::max(interaction_domain.z1, domain_with_fsi_envelope.z1)
	);

	grid.set_min_cell_size(interaction_distance);
	grid.clear();
	grid.repartition();

	rebuild_neighbor_proc_list();
	rebuild_boundary_cell_list();
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::rebuild_neighbor_proc_list()
{
	T envelope_width = particle_max_radius + std::max(Dirac::half_support, interaction_distance);

	// Find all atomic blocks that are within the envelope width of this processor
	const SparseBlockStructure3D & robot = management.getSparseBlockStructure();
	const ThreadAttribution & thread_info = management.getThreadAttribution();

	std::vector<plint> neighbor_procs;
	std::vector<plint> neighbor_blocks;
	std::vector<std::pair<geo::Rect<T>, plint> > domain_proc_map;

	// Find blocks that are within particle_max_radius+envelope_width of this domain.
	geo::Rect<T> domain_to_test(domain);
	domain_to_test.enlarge_inplace(envelope_width);
	find_blocks_in_domain(domain_to_test, neighbor_blocks);

	for(std::vector<plint>::iterator it = neighbor_blocks.begin(); it != neighbor_blocks.end(); ++it) {
		plint pid = thread_info.getMpiProcess(*it);
		if(pid != global::mpi().getRank()) {
			Box3D box;
			robot.getBulk(*it, box);
			geo::Rect<T> dom(box);
			dom.enlarge_inplace(std::max(Dirac::half_support, interaction_distance));

			neighbor_procs.push_back(pid);
			domain_proc_map.push_back(std::make_pair(dom, pid));
		}
	}
	std::sort(neighbor_procs.begin(), neighbor_procs.end());
	std::unique(neighbor_procs.begin(), neighbor_procs.end());

	particle_force_communicator.set_proc_list(neighbor_procs);
	particle_force_communicator.set_domain_proc_map(domain_proc_map);
	particle_state_communicator.set_proc_list(neighbor_procs);
	particle_state_communicator.set_domain_proc_map(domain_proc_map);
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::rebuild_boundary_cell_list()
{
	// Find cells adjacent to the boundary
	boundary_cells.clear();
	if(has_boundary()) {
		Box3D dom = grid.get_bulk_indices();
		for(pluint i = dom.x0; i <= dom.x1; ++i) {
			for(pluint j = dom.y0; j <= dom.y1; ++j) {
				for(pluint k = dom.z0; k <= dom.z1; ++k) {
					typename GridType::CellType & cell = grid.get_cell(i, j, k);

					if(boundary->does_intersect(cell.domain, interaction_distance)) {
						boundary_cells.push_back(&cell);
					}
				}
			}
		}
	}
}

template<class T, template<typename U> class Descriptor, class Periodicity>
ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::~ImmersedBoundaryDynamics3D()
{
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it)
		delete it->second;
	if(output_stream)
		delete output_stream;
}

/* Dry iteration */
template<class T, template<typename U> class Descriptor, class Periodicity>
	template<class InteractionFunctional>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::do_dry_iteration(const InteractionFunctional & interaction)
{
	// Update orientation and center of mass position of the particles
	move_particles();

	// Compute interaction forces
	compute_interaction_forces(interaction);

	// Integrate momentum equations
	for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
		it->second->integrate_momentum_no_fsi(iteration);
	}
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::move_particles()
{
	Profile::start_timer("Move particles");

	// Move all local particles
	ObjMapType updated_particle_map;
	particle_state_communicator.clear_send_buffer();
	for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
		if(it->second->get_proc_id() == global::mpi().getRank()) {
			it->second->move();

			// Map position to periodic grid
			arithmetic.remap_position(it->second->get_position());

			// Pack for neighboring processors
			particle_state_communicator.pack_particle(*it->second);

			if(geo::does_intersect(it->second->get_bounding_sphere(), domain_with_fsi_envelope, arithmetic))
				updated_particle_map[it->first] = it->second;
			else {
				if(management.getSparseBlockStructure().
						locate(std::floor(it->second->get_position()[0]+0.5), std::floor(it->second->get_position()[1]+0.5), std::floor(it->second->get_position()[2]+0.5))
						== -1) {
					std::cerr << "Warning: A particle is out of bounds!" << std::endl;
				}
			}
		}
	}

	// Send and receive the new state of the particles (non-blocking)
	particle_state_communicator.send_and_receive_no_wait();

	// Update the solid nodes of the local particles
	local_node_list.clear();
	envelope_node_list.clear();
	grid.clear();

	for(typename ObjMapType::iterator it = updated_particle_map.begin(),
			it_end = updated_particle_map.end(); it != it_end; ++it) {
		add_solid_nodes_from_particle(*it->second);

		// Remove the nodes from the old object_map
		particles.erase(it->first);
	}

	// Receive the new state of the non-local particles
	particle_state_communicator.finalize_send_and_receive();

	// Update the solid nodes of the non-local particles
	for(typename ParticleStateCommunicatorType::DataIterator it = particle_state_communicator.data_begin(),
			it_max = particle_state_communicator.data_end(); it != it_max; ++it) {

		// Check if the particle already exists in the domain
		ObjMapIterator p_it = particles.find(it->obj_id);
		RigidParticle3D<T> * particle;
		if(p_it != particles.end()) {
			particle = p_it->second;
			particles.erase(p_it);
		} else {
			particle = new RigidParticle3D<T>(shape_library.get_by_id(it->shape_id));
			particle->set_id(it->obj_id);
		}

		// Copy received data
		particle->get_position() = it->pos;
		particle->get_angular_velocity() = it->ang_vel;
		particle->get_velocity() = it->vel;
		particle->get_orientation() = it->orientation;
		particle->get_density() = it->density;
		particle->get_force() = it->force;
		particle->get_torque() = it->torque;
		particle->force_coll = it->force_coll;
		particle->force_coll_last = it->force_coll_last;
		particle->torque_coll = it->torque_coll;
		particle->torque_coll_last = it->torque_coll_last;
		particle->update_rotation_matrix();

		updated_particle_map[it->obj_id] = particle;
		add_solid_nodes_from_particle(*particle);
	}

	// Remove all particles no longer residing in the domain
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it)
		delete it->second;

	particles.swap(updated_particle_map);

	// Set particle processor ids
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it)
		set_particle_proc_id(*it->second);

	Profile::stop_timer("Move particles");
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::set_particle_proc_id(RigidParticle3D<T> & p)
{
	plint particle_block_id = management.getSparseBlockStructure().
				locate(std::floor(p.get_position()[0]+0.5), std::floor(p.get_position()[1]+0.5), std::floor(p.get_position()[2]+0.5));
	if(particle_block_id == -1)
		std::cerr << "Warning: A particle is out of bounds!" << std::endl;
	p.set_proc_id(management.getThreadAttribution().getMpiProcess(particle_block_id));
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::add_solid_nodes_from_particle(RigidParticle3D<T> & p)
{
	Array<T, 3> pos;
	SolidNode<T> node;
	ParticleNodeInfo<T> node_info;
	const Array<T, 3> mid(0.5 * (domain.x0 + domain.x1),
						  0.5 * (domain.y0 + domain.y1),
						  0.5 * (domain.z0 + domain.z1));

	// Generate nodes
	for(pluint i = 0, i_max = p.get_vertex_count(); i < i_max; ++i) {
		p.get_centroid_world_frame(i, pos);

		// If the grid is periodic, move the position a multiple of the global domain extent so that
		// the position is as close to the center of the local domain as possible
		arithmetic.shift_periodically_to_minimize_distance_to(mid, pos);

		// Check if the node is contained in this domain
		if(domain_bounds.contains_or_on_boundary(pos))
		{
			// Generate node
			p.get_node_info(i, node_info);
			node.vel = node_info.vel;
			node.area = node_info.area;
			node.pos_rel = node_info.pos_rel;
			node.normal = node_info.normal;
			node.pos = pos;
			node.obj_id = p.get_id();
			node.node_id = i;
			node.particle = &p;

			// Check if the point is in the bulk or envelope domain
			if(bulk_domain.contains(pos)) {
				local_node_list.push_node(node);
			} else if(domain_with_fsi_envelope.contains(pos)){
				envelope_node_list.push_node(node);
			}

			// Put in grid
			if(interaction_domain.contains(pos))
				grid.insert(node, node.pos);
		}
	}
	//std::cout << "Proc " << global::mpi().getRank() << ", envelope node count = " << envelope_node_list.size() << ", local node count = " << local_node_list.size() << std::endl;
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
	template<class InteractionFunctional>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::compute_interaction_forces(const InteractionFunctional & interaction)
{
	Profile::start_timer("Interaction force computation");

	// Reset collision forces and torques to zero
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it) {
		it->second->force_coll_last = it->second->force_coll;
		it->second->torque_coll_last = it->second->torque_coll;
		it->second->force_coll.resetToZero();
		it->second->torque_coll.resetToZero();
	}

	// Particle-particle interactions
	// Here the values are evaluated in the world fixed coordinate system
	if(particles.size() > 1) {
		const Box3D dom = grid.get_bulk_indices();

		// Do collision for all inner cells
		for(pluint i = dom.x0; i <= dom.x1; ++i) {
			for(pluint j = dom.y0; j <= dom.y1; ++j) {
				for(pluint k = dom.z0; k <= dom.z1; ++k) {
					typename GridType::CellType & cell = grid.get_cell(i, j, k);

					// Neighbor cells
					typename GridType::CellType * neighbor_cells[7] = {
								&grid.get_cell(i, j+1, k),
								&grid.get_cell(i, j+1, k+1),
								&grid.get_cell(i, j, k+1),
								&grid.get_cell(i+1, j, k),
								&grid.get_cell(i+1, j+1, k),
								&grid.get_cell(i+1, j+1, k+1),
								&grid.get_cell(i+1, j, k+1)
							};

					for(pluint l = 0; l < cell.nodes.size(); ++l) {
						const SolidNode<T> & node = cell.nodes[l];

						// Same-cell collisions
						for(pluint m = (l+1); m < cell.nodes.size(); ++m)
							handle_collision(node, cell.nodes[m], interaction);

						// Neighboring cells
						for(pluint n_it = 0; n_it < 7; ++n_it) {
							for(pluint m = 0; m < neighbor_cells[n_it]->nodes.size(); ++m)
								handle_collision(node, neighbor_cells[n_it]->nodes[m], interaction);
						}
					}
				}
			}
		}

		// Treat the case when the domain has periodic edges
		if(has_periodic_edge[0]) {
			//std::cout << "Periodic x" << std::endl;
			for(plint j = dom.y0; j <= dom.y1; ++j)
				for(plint k = dom.z0; k <= dom.z1; ++k)
					collide_all_in_cells(grid.get_cell(dom.x0, j, k), grid.get_cell(dom.x1, j, k), interaction);
		}

		if(has_periodic_edge[1]) {
			//std::cout << "Periodic y" << std::endl;
			for(plint i = dom.x0; i <= dom.x1; ++i)
				for(plint k = dom.z0; k <= dom.z1; ++k)
					collide_all_in_cells(grid.get_cell(i, dom.y0, k), grid.get_cell(i, dom.y1, k), interaction);
		}

		if(has_periodic_edge[2]) {
			//std::cout << "Periodic z" << std::endl;
			for(plint i = dom.x0; i <= dom.x1; ++i)
				for(plint j = dom.y0; j <= dom.y1; ++j)
					collide_all_in_cells(grid.get_cell(i, j, dom.z0), grid.get_cell(i, j, dom.z1), interaction);
		}

		if(has_periodic_edge[0] && has_periodic_edge[1]) {
			//std::cout << "Periodic xy" << std::endl;
			for(plint k = dom.z0; k <= dom.z1; ++k)
				collide_all_in_cells(grid.get_cell(dom.x0, dom.y0, k), grid.get_cell(dom.x1, dom.y1, k), interaction);
		}

		if(has_periodic_edge[0] && has_periodic_edge[2]) {
			//std::cout << "Periodic xz" << std::endl;
			for(plint j = dom.y0; j <= dom.y1; ++j)
				collide_all_in_cells(grid.get_cell(dom.x0, j, dom.z0), grid.get_cell(dom.x1, j, dom.z1), interaction);
		}

		if(has_periodic_edge[1] && has_periodic_edge[2]) {
			//std::cout << "Periodic yz" << std::endl;
			for(plint i = dom.x0; i <= dom.x1; ++i)
				collide_all_in_cells(grid.get_cell(i, dom.y0, dom.z0), grid.get_cell(i, dom.y1, dom.z1), interaction);
		}

		if(has_periodic_edge[0] && has_periodic_edge[1] && has_periodic_edge[2]) {
			//std::cout << "Periodic xyz" << std::endl;
			collide_all_in_cells(grid.get_cell(dom.x0, dom.y0, dom.z0), grid.get_cell(dom.x1, dom.y1, dom.z1), interaction);
		}
	}

	// Particle-wall interactions
	if(has_boundary()) {
		for(typename BoundaryCellContainerType::iterator it = boundary_cells.begin(); it != boundary_cells.end(); ++it) {
			typename GridType::CellType & cell = *(*it);
			for(plint i = 0; i < cell.nodes.size(); ++i) {
				SolidNode<T> & node = cell.nodes[i];

				//std::cout << boundary->distance_to_boundary(node.pos) << std::endl;
				if(boundary->distance_to_boundary_less_than(node.pos, interaction_distance)) {
					Array<T, 3> df = -interaction(boundary->distance_to_boundary(node.pos))
							* node.area * boundary->get_normal(node.pos);

					RigidParticle3D<T> & p = *(particles.at(node.obj_id));
					p.force_coll += df;
					p.torque_coll += crossProduct(node.pos_rel, df);
				}
			}
		}
	}

	// Synchronize
	particle_force_communicator.send_and_receive_no_wait(ParticleForceCommunicatorType::CollForce);
	particle_force_communicator.finalize_send_and_receive(ParticleForceCommunicatorType::CollForce);

	// Transform the torque to the body fixed system
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it)
		it->second->torque_coll = it->second->get_orientation().apply_inv_rotation(it->second->torque_coll);
	Profile::stop_timer("Interaction force computation");
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
	template<class InteractionFunctional>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::collide_all_in_cells(
		typename GridType::CellType & cell1,
		typename GridType::CellType & cell2,
		const InteractionFunctional & interaction
)
{
	for(pluint l = 0; l < cell1.nodes.size(); ++l)
		for(pluint m = 0; m < cell2.nodes.size(); ++m)
			handle_collision(cell1.nodes[l], cell2.nodes[m], interaction);
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
	template<class InteractionFunctional>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::handle_collision(
		const SolidNode<T> & node,
		const SolidNode<T> & node2,
		const InteractionFunctional & interaction)
{
	if(node.obj_id != node2.obj_id) {
		const Array<T, 3> dr = arithmetic.vec_diff(node2.pos, node.pos);
		const T dist_sqr = normSqr(dr);

		if(dist_sqr <= interaction_distance_sqr) {
			const T dist =  std::sqrt(dist_sqr);
			T df = -interaction(dist);

			RigidParticle3D<T> & p = *(particles.at(node.obj_id));
			RigidParticle3D<T> & p2 = *(particles.at(node2.obj_id));

			p.force_coll += df * node.area * node.normal;
			p.torque_coll += crossProduct(node.pos_rel, df * node.area * node.normal);
			p2.force_coll += df * node2.area * node2.normal;
			p2.torque_coll += crossProduct(node2.pos_rel, df * node2.area * node2.normal);
		}
	}
}

/*
 * do_fsi
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
	template<class InteractionFunctional>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::do_fsi(
		Box3D dom,
		BlockLattice3D<T, Descriptor> & lattice,
		ScalarField3D<T> & density,
		TensorField3D<T, 3> & velocity,
		const Array<T, 3> & external_force,
		const InteractionFunctional & interaction)
{
	// Update orientation and center of mass position of the particles
	move_particles();

	// Compute interaction forces
	compute_interaction_forces(interaction);

	// 1st stage of linear and angular velocity integration
	for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
		it->second->integrate_momentum_1st_stage(iteration, external_force);
		it->second->get_force().resetToZero();
		it->second->get_torque().resetToZero();
	}

	for(pluint it = 0; it < fsi_subiterations; ++it) {
		compute_fsi_forces(dom, lattice, density, velocity);

		for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
			//it->second->integrate_momentum_2nd_stage(iteration);
			it->second->get_torque() += it->second->torque_tmp;
			it->second->get_force() += it->second->force_tmp;
		}
		update_solid_nodes_velocities();
	}
}

inline void restrict_box(Box3D & box, const Box3D & domain)
{
	if(box.x0 < domain.x0) box.x0 = domain.x0;
	if(box.x1 > domain.x1) box.x1 = domain.x1;
	if(box.y0 < domain.y0) box.y0 = domain.y0;
	if(box.y1 > domain.y1) box.y1 = domain.y1;
	if(box.z0 < domain.z0) box.z0 = domain.z0;
	if(box.z1 > domain.z1) box.z1 = domain.z1;
}

/*
 * Fsi force computation
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::compute_fsi_forces(
		Box3D dom,
		BlockLattice3D<T, Descriptor> & lattice,
		ScalarField3D<T> & density,
		TensorField3D<T, 3> & velocity)
{
	static T acceleration_factor = 1.9;

#ifdef FSI_COMPUTE_RESIDUAL
	T delta_u_max = 0;
	T delta_u_l2 = 0;
#endif

	// Reset temporary forces on particles
	for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
		it->second->force_tmp.resetToZero();
		it->second->torque_tmp.resetToZero();
	}

	// Offsets between the lattices
	Dot3D density_offset = computeRelativeDisplacement(lattice, density);
	Dot3D velocity_offset = computeRelativeDisplacement(lattice, velocity);
	Dot3D offset = lattice.getLocation();

	// Temporary variables
	Array<T, 3> vel_fluid;
	Box3D d_bounds;
	T dirac_x, dirac_xy, dirac_val;
	std::vector<T> dirac_values(Dirac::support * Dirac::support * Dirac::support);

	// Process the nodes in the fsi envelope
	Profile::start_timer("Envelope interpolation");
	fsi_force_communicator.clear_data();
	for(pluint ni = 0, ni_max = envelope_node_list.size(); ni < ni_max; ++ni) {
		SolidNode<T> & node = envelope_node_list[ni];

		const Array<T, 3> & pos = node.pos;
		const Array<T, 3> pos_rel(pos[0] - offset.x, pos[1] - offset.y, pos[2] - offset.z);

		// Find compact support region of the Dirac function
		get_dirac_compact_support_box<T, Dirac>(pos_rel, d_bounds);

		// Interpolate fluid velocity
		vel_fluid.resetToZero();
		pluint cnt = 0;
		for(plint i = d_bounds.x0; i <= d_bounds.x1; ++i) {
			plint i2 = i;
			if(has_periodic_edge[0]) arithmetic.remap_index_x(i2, offset.x);
			if(i2 < dom.x0 || i2 > dom.x1) continue;

			dirac_x = Dirac::eval((T)i - pos_rel[0]);
			for(plint j = d_bounds.y0; j <= d_bounds.y1; ++j) {
				plint j2 = j;
				if(has_periodic_edge[1]) arithmetic.remap_index_y(j2, offset.y);
				if(j2 < dom.y0 || j2 > dom.y1) continue;

				dirac_xy = dirac_x * Dirac::eval((T)j - pos_rel[1]);
				for(plint k = d_bounds.z0; k <= d_bounds.z1; ++k) {
					plint k2 = k;
					if(has_periodic_edge[2]) arithmetic.remap_index_z(k2, offset.z);
					if(k2 < dom.z0 || k2 > dom.z1) continue;

					dirac_val = dirac_xy * Dirac::eval((T)k - pos_rel[2]);
					vel_fluid += (dirac_val * velocity.get(i2 + velocity_offset.x,
												 j2 + velocity_offset.y,
												 k2 + velocity_offset.z));
					dirac_values[cnt] = dirac_val;
					++cnt;
				}
			}
		}

		const Array<T, 3> delta_u = ((T) cnt / (T)(Dirac::support*Dirac::support*Dirac::support) * node.vel - vel_fluid)
												* node.area * acceleration_factor;

		// Spread velocity correction to the fluid
		T factor = 0;
		cnt = 0;
		for(plint i = d_bounds.x0; i <= d_bounds.x1; ++i) {
			plint i2 = i;
			if(has_periodic_edge[0]) arithmetic.remap_index_x(i2, offset.x);
			if(i2 < dom.x0 || i2 > dom.x1) continue;
			for(plint j = d_bounds.y0; j <= d_bounds.y1; ++j) {
				plint j2 = j;
				if(has_periodic_edge[1]) arithmetic.remap_index_y(j2, offset.y);
				if(j2 < dom.y0 || j2 > dom.y1) continue;
				for(plint k = d_bounds.z0; k <= d_bounds.z1; ++k) {
					plint k2 = k;
					if(has_periodic_edge[2]) arithmetic.remap_index_z(k2, offset.z);
					if(k2 < dom.z0 || k2 > dom.z1) continue;

					const T multiple = density.get(i2 + density_offset.x,
												 j2 + density_offset.y,
												 k2 + density_offset.z)
											 * dirac_values[cnt] * 2.0;
					factor += multiple;

					T * g = lattice.get(i2, j2, k2).getExternal(Descriptor<T>::ExternalField::forceBeginsAt);
					g[0] += delta_u[0] * multiple;
					g[1] += delta_u[1] * multiple;
					g[2] += delta_u[2] * multiple;

					++cnt;
				}
			}
		}

		// Add force contribution to the appropriate particle
		const Array<T, 3> force_local = -factor * delta_u;
		node.particle->force_tmp += force_local;
		node.particle->torque_tmp += crossProduct(node.pos_rel, force_local);

		// Pack for mpi send
		const VelocityInterpolationNode<T> send_node = {delta_u, node.pos, node.pos_rel, node.obj_id};
		fsi_force_communicator.add_data(send_node);
	}
	Profile::stop_timer("Envelope interpolation");

	// Send and receive (non-blocking)
	fsi_force_communicator.send_and_receive_no_wait();

	// Process the local nodes while waiting for data to arrive
	Profile::start_timer("Bulk fsi");
	for(pluint ni = 0, ni_max = local_node_list.size(); ni < ni_max; ++ni) {
		SolidNode<T> & node = local_node_list[ni];
		const Array<T, 3> & pos = node.pos;
		const Array<T, 3> pos_rel(pos[0] - offset.x, pos[1] - offset.y, pos[2] - offset.z);

		// Find compact support region of the Dirac function
		get_dirac_compact_support_box<T, Dirac>(pos_rel, d_bounds);

		// Interpolate fluid velocity
		// Since these nodes are completely local, no special treatment such as
		// out of bounds checks or periodicity imposing is required.
		vel_fluid.resetToZero();
		plint cnt = 0;
		for(plint i = d_bounds.x0; i <= d_bounds.x1; ++i) {
			dirac_x = Dirac::eval((T)i - pos_rel[0]);
			for(plint j = d_bounds.y0; j <= d_bounds.y1; ++j) {
				dirac_xy = dirac_x * Dirac::eval((T)j - pos_rel[1]);
				for(plint k = d_bounds.z0; k <= d_bounds.z1; ++k) {
					dirac_val = dirac_xy * Dirac::eval((T)k - pos_rel[2]);
					dirac_values[cnt] = dirac_val;
					vel_fluid += dirac_val * velocity.get(i + velocity_offset.x,
													 j + velocity_offset.y,
													 k + velocity_offset.z);
					++cnt;
				}
			}
		}

		// Area-weighted velocity correction
		const Array<T, 3> delta_u = (node.vel - vel_fluid) * node.area * acceleration_factor;

#ifdef FSI_COMPUTE_RESIDUAL
		for(pluint k = 0; k < 3; ++k)
			delta_u_max = std::abs(delta_u[k]) > delta_u_max ? std::abs(delta_u[k]) : delta_u_max;
		delta_u_l2 += normSqr(delta_u);
#endif

		// Spread the velocity correction and compute the corresponding force addition
		cnt = 0;
		T factor = 0;
		for(plint i = d_bounds.x0; i <= d_bounds.x1; ++i)
			for(plint j = d_bounds.y0; j <= d_bounds.y1; ++j)
				for(plint k = d_bounds.z0; k <= d_bounds.z1; ++k) {
					const T multiple = density.get(i + density_offset.x,
										 j + density_offset.y,
										 k + density_offset.z)
												 * dirac_values[cnt] * 2.0;
					factor += multiple;
					T * g = lattice.get(i, j, k).getExternal(Descriptor<T>::ExternalField::forceBeginsAt);
					g[0] += delta_u[0] * multiple;
					g[1] += delta_u[1] * multiple;
					g[2] += delta_u[2] * multiple;

					++cnt;
				}

		// Add force and torque contribution to particle
		node.particle->force_tmp -= factor * delta_u;
		node.particle->torque_tmp -= factor * crossProduct(node.pos_rel, delta_u);
	}
	Profile::stop_timer("Bulk fsi");

	// Synchronize with neighboring processors
	Profile::start_timer("Fsi force synchronization");
	fsi_force_communicator.finalize_send_and_receive();
	Profile::stop_timer("Fsi force synchronization");

	// Spread the contribution from neighboring processors
	Profile::start_timer("Fsi force envelope spreading");
	const Array<T, 3> mid(0.5 * (domain.x0 + domain.x1),
							  0.5 * (domain.y0 + domain.y1),
							  0.5 * (domain.z0 + domain.z1));
	for(typename FsiForceCommunicatorType::IteratorType it = fsi_force_communicator.data_begin(),
			it_end = fsi_force_communicator.data_end();
			it != it_end; ++it) {

		Array<T, 3> pos = it->pos;
		arithmetic.shift_periodically_to_minimize_distance_to(mid, pos);
		const Array<T, 3> pos_rel(
				pos[0] - offset.x,
				pos[1] - offset.y,
				pos[2] - offset.z);

		get_dirac_compact_support_box<T, Dirac>(pos_rel, d_bounds);

		// Spread velocity correction to the fluid
		T factor = 0;
		for(plint i = d_bounds.x0; i <= d_bounds.x1; ++i) {
			plint i2 = i;
			if(has_periodic_edge[0]) arithmetic.remap_index_x(i2, offset.x);
			if(i2 < dom.x0 || i2 > dom.x1) continue;

			dirac_x = Dirac::eval((T)i - pos_rel[0]);
			for(plint j = d_bounds.y0; j <= d_bounds.y1; ++j) {
				plint j2 = j;
				if(has_periodic_edge[1]) arithmetic.remap_index_y(j2, offset.y);
				if(j2 < dom.y0 || j2 > dom.y1) continue;

				dirac_xy = dirac_x * Dirac::eval((T)j - pos_rel[1]);
				for(plint k = d_bounds.z0; k <= d_bounds.z1; ++k) {
					plint k2 = k;
					if(has_periodic_edge[2]) arithmetic.remap_index_z(k2, offset.z);
					if(k2 < dom.z0 || k2 > dom.z1) continue;

					const T multiple = density.get(i2 + density_offset.x,
												 j2 + density_offset.y,
												 k2 + density_offset.z)
											 * dirac_xy * Dirac::eval((T)k - pos_rel[2]) * 2.0;
					factor += multiple;

					T * g = lattice.get(i2, j2, k2).getExternal(Descriptor<T>::ExternalField::forceBeginsAt);
					g[0] += it->delta_u[0] * multiple;
					g[1] += it->delta_u[1] * multiple;
					g[2] += it->delta_u[2] * multiple;
				}
			}
		}

		// Add force contribution to the appropriate particle
		RigidParticle3D<T> * particle = particles.at(it->obj_id);
		const Array<T, 3> force_local = -factor * it->delta_u;
		particle->force_tmp += force_local;
		particle->torque_tmp += crossProduct(it->pos_rel, force_local);
	}
	Profile::stop_timer("Fsi force envelope spreading");

	// Communicate particle forces
	particle_force_communicator.send_and_receive_no_wait(ParticleForceCommunicatorType::TmpForce);

	// Update the fluid velocity in the domain
	Profile::start_timer("Update velocity");
	if(particles.size() != 0) {
		for(plint i = dom.x0; i <= dom.x1; ++i) {
			for(plint j = dom.y0; j <= dom.y1; ++j) {
				for(plint k = dom.z0; k <= dom.z1; ++k) {
					lattice.get(i, j, k).computeVelocity(
							velocity.get(i+velocity_offset.x,
									j+velocity_offset.y,
									k+velocity_offset.z));
				}
			}
		}
	}
	Profile::stop_timer("Update velocity");

	// Wait for data to arrive
	Profile::start_timer("Particle force synchronization");
	particle_force_communicator.finalize_send_and_receive(ParticleForceCommunicatorType::TmpForce);
	Profile::stop_timer("Particle force synchronization");

	// Transform the temporary torque to body fixed coordinates
	for(typename ObjMapType::iterator it = particles.begin(), it_end = particles.end(); it != it_end; ++it) {
		it->second->torque_tmp = it->second->get_orientation().apply_inv_rotation(it->second->torque_tmp);
	}
#ifdef FSI_COMPUTE_RESIDUAL
	T delta_u_max_recv, delta_u_l2_recv;
	global::mpi().reduce(delta_u_max, delta_u_max_recv, MPI_MAX);
	global::mpi().reduce(delta_u_l2, delta_u_l2_recv, MPI_SUM);

	if(global::mpi().isMainProcessor())
		std::cout << delta_u_max_recv << " " << std::sqrt(delta_u_l2_recv) << std::endl;
#endif
}

template<typename T, template< typename U > class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::update_solid_nodes_velocities()
{
	// Update local nodes
	for(pluint i = 0, i_max = local_node_list.size(); i < i_max; ++i) {
		SolidNode<T> & node = local_node_list[i];
		particles.at(node.obj_id)->get_node_velocity_world_frame(node.node_id, node.vel);
	}

	// Update envelope nodes
	for(pluint i = 0, i_max = envelope_node_list.size(); i < i_max; ++i) {
		SolidNode<T> & node = envelope_node_list[i];
		particles.at(node.obj_id)->get_node_velocity_world_frame(node.node_id, node.vel);
	}
}

/*
 * add_particle
 * Adds a particle to the simulation. Particles not in the domain are discarded.
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::add_particle(RigidParticle3D<T> * particle)
{
	// Does the neighboring processor list need to be rebuilt?
	if(particle->get_radius() > particle_max_radius) {
		particle_max_radius = particle->get_radius();
		rebuild_neighbor_proc_list();
	}

	// Create an id for the particle.
	plint p_id = get_next_id();

	// Check if the particle's bounding sphere is in this domain
	if( ! geo::does_intersect(particle->get_bounding_sphere(), domain_with_fsi_envelope, arithmetic))
		return;

	// Copy the particle
	RigidParticle3D<T> * p_copy = particle->clone();

	// Set particle id
	p_copy->set_id(p_id);

	set_particle_proc_id(*p_copy);

	// Save the particle
	particles[p_id] = p_copy;
	add_solid_nodes_from_particle(*p_copy);
}

/*
 * Particle overlap testing
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
bool ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::has_overlapping_particles() const
{
	int overlap_found = 0;
/*	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it) {
		for(typename ObjMapType::iterator it2 = it+1; it2 != particles.end(); ++it2) {
			// Do bounding sphere test
			if(does_intersect(it->second->get_bounding_sphere(), it2->second->get_bounding_sphere(), arithmetic)) {
				if(it->second->intersects(*(it2->second))) {
					overlap_found = 1;
					break;
				}
			}
		}

		if(overlap_found)
			break;
	}

	global::mpi().reduceAndBcast(overlap_found, MPI_LAND);
*/
	return overlap_found;
}

/*
 * Count total number of particles
 * NOTE: this method performs a reduction over all processors and is therefore SLOW. Use with care.
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
pluint ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::count_particles() const
{
	plint num_particles = 0;
	for(typename ObjMapType::const_iterator it = particles.begin(); it != particles.end(); ++it) {
		if(it->second->get_proc_id() == global::mpi().getRank())
			++num_particles;
	}

#ifdef PLB_MPI_PARALLEL
	global::mpi().reduceAndBcast(num_particles, MPI_SUM);
#endif

	return num_particles;
}


/*
 * Output
 */
template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::write_particles_as_vtk(pluint iter, T scale)
{
	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it) {
		if(it->second->get_proc_id() == global::mpi().getRank()) {
			std::stringstream fNameStream;
			fNameStream << global::directories().getVtkOutDir() << "obj" << std::setfill('0') << std::setw(4) << it->first
					<< "-" << std::setfill('0') << std::setw(6) << iter
					<<".vtu";

			std::ofstream out;
			out.open( fNameStream.str().c_str(), std::ios_base::trunc);

			if( ! out.good()) {
				std::cerr << "Could not open the file " << fNameStream.str() << " for writing." << std::endl;
			} else {
				it->second->write_to_stream_as_vtk(out, scale);
				out.close();
			}
		}
	}
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::write_particle_states(pluint iter)
{
	if( ! output_stream) {
		// Create file name
		std::stringstream fNameStream;
		fNameStream << global::directories().getVtkOutDir()
							  << "objsP" << std::setfill('0') << std::setw(6) << global::mpi().getRank() <<".txt";
		output_stream = new std::ofstream(fNameStream.str().c_str(), std::ios_base::out);

		// Print header
		*output_stream << "iteration particle_id position_x position_y position_z velocity_x velocity_y velocity_z "
				<< "orientation_scalar orientation_x orientation_y orientation_z "
				<< "angular_velocity_x angular_velocity_y angular_velocity_z "
				<< "force_x force_y force_z torque_x torque_y torque_z kinetic_energy" << std::endl;
	}

	for(typename ObjMapType::iterator it = particles.begin(); it != particles.end(); ++it) {
		if(it->second->get_proc_id() == global::mpi().getRank()) {
			RigidParticle3D<T> * p = it->second;
			*output_stream << iter << " "
							<< p->get_id() << " "
							<< p->get_position()[0] << " "
							<< p->get_position()[1] << " "
							<< p->get_position()[2] << " "
							<< p->get_velocity()[0] << " "
							<< p->get_velocity()[1] << " "
							<< p->get_velocity()[2] << " "
							<< p->get_orientation()[0] << " "
							<< p->get_orientation()[1] << " "
							<< p->get_orientation()[2] << " "
							<< p->get_orientation()[3] << " "
							<< p->get_angular_velocity()[0] << " "
							<< p->get_angular_velocity()[1] << " "
							<< p->get_angular_velocity()[2] << " "
							<< p->get_force()[0] << " "
							<< p->get_force()[1] << " "
							<< p->get_force()[2] << " "
							<< p->get_torque()[0] << " "
							<< p->get_torque()[1] << " "
							<< p->get_torque()[2] << " "
							<< p->compute_kinetic_energy()
							<< std::endl;
		}
	}
}


template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::save_checkpoint(const char * file_name) const
{
	// Output size of each particle
	const pluint particle_size = 10 * sizeof(Array<T, 3>) + sizeof(Quaternion<T>) + sizeof(pluint) + 2*sizeof(plint);
	Buffer<char> buffer(particle_size);

	// Create name for output folder
	std::stringstream ss;
	ss << global::directories().getOutputDir() << file_name;
	std::string folder = ss.str();

	// Create folder (this mkdir implementation is thread safe)
	io::mkdir(folder.c_str());

	// Write header file
	if(global::mpi().isMainProcessor()) {
		// Open header file (the header file has the same name as the folder, but with extension .plb)
		std::ofstream out((folder + std::string(".plb")).c_str(), std::ios::out);

		// Write shared particle information
		out << particle_max_radius << std::endl;
		out << num_particles << std::endl;

		// Write file information
		out << global::mpi().getSize() << std::endl;
		for(plint i = 0; i < global::mpi().getSize(); ++i) {
			std::stringstream fss;
			fss << folder << "/" << std::setfill('0') << std::setw(6) << i << ".plb";
			out << fss.str() << std::endl;
		}
		out.close();
	}

	// Open output file
	ss << "/" << std::setfill('0') << std::setw(6) << global::mpi().getRank() << ".plb";
	std::ofstream out(ss.str().c_str(), std::ios::binary|std::ios::out);
	if( ! out.is_open()) {
		std::cerr << "Could not open the checkpoint file " << file_name << " for writing" << std::endl;
		return;
	}

	// Count local particles and write to file
	plint p_size = 0;
	for(typename ObjMapType::const_iterator it = particles.begin(); it != particles.end(); ++it)
		if(it->second->get_proc_id() == global::mpi().getRank())
			++p_size;

	out.write((char *) &p_size, sizeof(plint));

	// Serialize the particles
	for(typename ObjMapType::const_iterator it = particles.begin(); it != particles.end(); ++it) {
		if(it->second->get_proc_id() == global::mpi().getRank()) {
			buffer.rewind_ptr();
			buffer.pack(it->second->get_shape_id());
			buffer.pack(it->second->get_id());
			buffer.pack(it->second->get_position());
			buffer.pack(it->second->get_velocity());
			buffer.pack(it->second->get_angular_velocity());
			buffer.pack(it->second->get_orientation());
			buffer.pack(it->second->get_angular_velocity());
			buffer.pack(it->second->get_density());
			buffer.pack(it->second->get_force());
			buffer.pack(it->second->get_torque());
			buffer.pack(it->second->force_coll);
			buffer.pack(it->second->force_coll_last);
			buffer.pack(it->second->torque_coll);
			buffer.pack(it->second->torque_coll_last);

			buffer.rewind_ptr();
			out.write(buffer.get_data_ptr(), particle_size);
		}
	}
	out.close();
}

template<class T, template<typename U> class Descriptor, class Periodicity>
void ImmersedBoundaryDynamics3D<T, Descriptor, Periodicity>::load_checkpoint(const char * file_name)
{
	// Create name for output folder
	std::stringstream ss;
	ss << global::directories().getOutputDir() << file_name;
	std::string folder = ss.str();

	// Clear everything particle-related
	particles.clear();
	local_node_list.clear();
	envelope_node_list.clear();
	grid.clear();

	// Communication
	const pluint particle_size = 10 * sizeof(Array<T, 3>) + sizeof(Quaternion<T>) + sizeof(pluint) + 2*sizeof(plint);
	const pluint particles_per_message = 40;
	const pluint message_envelope_size = sizeof(bool) + sizeof(plint);
	const pluint message_size = message_envelope_size + particles_per_message * particle_size;
	Buffer<char> buffer(message_size);
	pluint particles_received;

	// Temporal variables
	plint num_local_particles;
	plint p_id;
	pluint shape_id;

	std::vector<std::string> file_list;
	file_list.clear();
	T particle_max_radius_;
	plint num_particles_;

	// Read header file
	if(global::mpi().isMainProcessor()) {
		std::ifstream in((folder + std::string(".plb")).c_str(), std::ios::in);

		if( ! in.is_open()) {
			pcerr << "Could not open the checkpoint file " << folder << ".plb. Does it exist?" << std::endl;
			exit(-1);
		}

		// Read number of particles and particle max radius
		in >> particle_max_radius_;
		in >> num_particles_;

		// Read file names
		pluint num_files;
		std::string file_name;
		in >> num_files;
		while(std::getline(in, file_name)) {
			if( ! file_name.empty())
				file_list.push_back(file_name);
		}
		in.close();
	}

	if(file_list.empty())
		pcerr << "Possible error in the checkpoint header file " << folder << ".plb: No checkpoint files specified" << std::endl;

	global::mpi().bCast(&particle_max_radius_, 1);
	global::mpi().bCast(&num_particles_, 1);

	this->particle_max_radius = particle_max_radius_;
	this->num_particles = num_particles_;

	// Now that we know the maximal radius of all particles, rebuild the neighbor processor list
	rebuild_neighbor_proc_list();

	// Read all particle states. Note that the main processor does all the reading,
	// and the read information is then broadcasted to all other processors.
	bool keep_reading = true;
	std::vector<std::string>::iterator file_it = file_list.begin();
	plint particles_left_in_file = 0;
	std::ifstream * stream = 0;

	while(keep_reading) {
		if(global::mpi().isMainProcessor()) {
			// Pack dummy values for keep_reading and number of particles
			buffer.rewind_ptr();
			buffer.pack(keep_reading);
			buffer.pack(particles_received);

			// Read particles_per_message particle states from checkpoint files
			particles_received = 0;
			for(pluint i = 0; i < particles_per_message; ++i) {
				// If we have reached the end of the current file, proceed with the next one
				while(particles_left_in_file == 0) {
					if(stream)
						delete stream;

					if(file_it == file_list.end()) {
						keep_reading = false;
						break;
					}

					stream = new std::ifstream(file_it->c_str(), std::ios::binary | std::ios::in);

					if( ! stream->is_open())
						pcerr << "Could not open the checkpoint file " << *file_it << std::endl;

					// Read number of particles in file
					stream->read((char *) &particles_left_in_file, sizeof(plint));

					++file_it;
				}

				if( ! keep_reading)
					break;

				// Read particle data
				stream->read(buffer.get_data_ptr(), particle_size);
				buffer.advance_ptr(particle_size);

				++particles_received;
				--particles_left_in_file;
			}

			// Set appropriate values for keep_reading and particles_received
			buffer.rewind_ptr();
			buffer.pack(keep_reading);
			buffer.pack(particles_received);
		}

		// Broadcast the read data
		buffer.rewind_ptr();
		global::mpi().bCast(buffer.get_data_ptr(), message_size);

		buffer.unpack(keep_reading);
		buffer.unpack(particles_received);

		for(plint i = 0; i < particles_received; ++i) {
			// Read shape id and create the particle
			buffer.unpack(shape_id);
			RigidParticle3D<T> * particle = new RigidParticle3D<T>(shape_library.get_by_id(shape_id));

			// Read and set id
			buffer.unpack(p_id);
			particle->set_id(p_id);

			// Read all other quantities
			buffer.unpack(particle->get_position());
			buffer.unpack(particle->get_velocity());
			buffer.unpack(particle->get_angular_velocity());
			buffer.unpack(particle->get_orientation());
			buffer.unpack(particle->get_angular_velocity());
			buffer.unpack(particle->get_density());
			buffer.unpack(particle->get_force());
			buffer.unpack(particle->get_torque());
			buffer.unpack(particle->force_coll);
			buffer.unpack(particle->force_coll_last);
			buffer.unpack(particle->torque_coll);
			buffer.unpack(particle->torque_coll_last);

			particle->update_rotation_matrix();

			// Check that the file does intersect with the current domain
			if( ! geo::does_intersect(particle->get_bounding_sphere(), domain_with_fsi_envelope, arithmetic))
				continue;

			// Set processor id
			set_particle_proc_id(*particle);

			// Save the particle
			particles[p_id] = particle;
			add_solid_nodes_from_particle(*particle);
		}
	}
}

} /* namespace fsi */

} /* namespace plb */

#endif /* IMMERSEDBOUNDARYDYNAMICS_HH_ */
